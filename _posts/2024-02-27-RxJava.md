---
title: "RxJava Observable Introducation"
date: 2024-02-18
---

# Introduction
RxJava is a Java VM implementation of [ReactiveX](https://reactivex.io/). It facilitates the asynchronous programming by allowing you to compose operators declaratively against sequences of data changes/events.

RxJava's *Observable* model is an abstraction of asynchronous sequences of multile items. 

| | Single Item | Multiple Items |
| --- | --- | --- |
| synchronous | T getData() | Iterable<T> getData() |
| asynchronous | Future<T> getData() | Observable<T> getData() |

In RxJava, source items could be generated by different ways, like thread-pools, event loops, non-blocking I/O, and etc. With *Observable* abstraction, engineers interact with them as asynchronous sequences. Later, the underlying generation could be radically changed without breaking the client code.

## Future<T> VS. Observable<T>
Future pattern works well in a single level of asynchronous execution but could become complicated when nested. Also, it doesn't support declaractive operator composition.

## Push VS. Pull
In its easiest example, RxJava *Observable* looks like Java 8 *Stream*, where both have alike operators (skip, filter, map, flatMap). However, they are for different purposes. *Observable* is mostly used when publishers asynchronously pushes data to consumers, while Stream is for synchronous pull (consumers ask for data from publishers).
```java
package rxjava.examples;

import io.reactivex.rxjava3.core.*;

public class HelloWorld {
    public static void main(String[] args) {
        List<String> names = List.of("Test", "", "World");
        // RxJava Observable's way
        Observable.fromIterable(names).skip(1).filter(s -> !s.isBlank()).map(s -> "Hello " + s + "!").subscribe(System.out::println);
        // Java Stream' way
        names.stream().skip(1).filter(s -> !s.isBlank()).map(s -> "Hello " + s + "!").forEach(System.out::println);
    }
}

```

## Cold VS. Hot Observables
There are two types of *Observable*s: cold and hot. The main difference is that observers always see all items in cold *Observable*s upon subscription while hot *Observable*s can emit items without observers. Late observers will miss earlier emission in hot *Observable*s.

| Feature | Cold Observable | Hot Observable |
| --- | --- | --- |
| Emission Starts | Upon subscription | Upon explicit method call |
| Data Source | Independent source for each observer | Single source shared by observers |
| Entire Sequence | Observers see all items | Observers do NOT see items before subscription |

# Usage Example
## Cold Observable
The following code snippet shows a typical usage of RxJava. It creates a Obervable to emit a string, map it to another value and *push* it to subscribers, which output the final value in console. Also, **subscribeOn** and **observeOn** change the thread of Observable and Observer.
```Java
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;

Observable.fromCallable(() -> {
        System.out.println("Callable in Thread: " + Thread.currentThread().getId());
        Thread.sleep(1000); //  imitate expensive computation
        return "world";
    }) // Observable run this to emit data
    .subscribeOn(Schedulers.io()) // Specify where Obervable itself will run to emit data
    .observeOn(Schedulers.single()) // Specify where observers will observe the data
    .map(s -> "Hello " + s + "!") // Map the data
    .subscribe(s -> {
        // print current thread id
        System.out.println("Output in Thread: " + Thread.currentThread().getId());
        System.out.println(s);
    }); // Observer run this to observe the data

System.out.println("Main thread id: " + Thread.currentThread().getId());
Thread.sleep(2000);
```
**Console Output:**
> Main thread id: 1<br>Callable in Thread: 23<br>Output in Thread: 24<br>Hello world!

## Hot Observable
```Java
Observable<String> source = Observable.just("Hello World!");
ConnectableObservable<String> connectable = source.publish();

Consumer<String> observer1 = value -> System.out.println("Observer 1: " + value);
Consumer<String> observer2 = value -> System.out.println("Observer 2 (delayed): " + value);

connectable.subscribe(observer1);

new Thread(() -> {
    try {
        Thread.sleep(1000); // Simulate a 1-second delay
                connectable.subscribe(observer2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();

connectable.connect();
```

**Console Output:**
> Observer 1: Hello World!